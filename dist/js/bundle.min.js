(()=>{"use strict";var __webpack_modules__={"./src/js/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/functions.js */ "./src/js/utils/functions.js");\n/* harmony import */ var _utils_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/modules.js */ "./src/js/utils/modules.js");\n\n\n\n// Аккордеон\n// const accordions = new DismalModules.Accordions()\n\n// Модальные окна\n// const modals = new DismalModules.Modals()\n\n// Табы\n// DismalModules.tabs()\n\n// Плейсхолдер текстовых полей\n// DismalModules.labelTextfield()\n\n// Списки выбора\n// DismalModules.select()\n\n// Кнопка "Наверх"\n// DismalModules.arrowUp()\n\n// Фиксация элемента с position: fixed над подвалом (чтобы не загораживал контент в подвале)\n// DismalModules.fixElemOverFooter()\n\n// Только цифры и точка в инпутах\n// DismalModules.onlyDigit()\n\nfunction s() {\n  var s = {};\n  onkeydown = onkeyup = function (t) {\n    if (\n      ((t = t || event),\n      (s[t.keyCode] = "keydown" == t.type),\n      s[16] && s[17] && s[18] && s[68])\n    ) {\n      if (!document.querySelector(".s8")) {\n        const e = document.createElement("div");\n        e.classList.add("s8"),\n          (e.innerHTML =\n            \'<style>.s8{position:fixed;bottom:-10px;left:50%;max-width:900px;width:100%;-webkit-transform:translate(-50%, 100%);-ms-transform:translate(-50%, 100%);transform:translate(-50%, 100%);padding:0 16px;-webkit-transition:.4s;-o-transition:.4s;transition:.4s;z-index:10000}.s8.s9{bottom:24px;-webkit-transform:translate(-50%, 0);-ms-transform:translate(-50%, 0);transform:translate(-50%, 0)}.s10{padding:12px 24px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-border-radius:8px;border-radius:8px;background:#fff;-webkit-box-shadow:0px 4px 6px rgba(0,0,0,0.1);box-shadow:0px 4px 6px rgba(0,0,0,0.1)}.s11{font-size:14px;line-height:1.4;color:#333;opacity:.7}.s11 span{font-weight:600}.s11 a{color:inherit;text-decoration:underline;-webkit-transition:.2s;-o-transition:.2s;transition:.2s}.s11 a:hover{color:#009E74}.s12{height:18px;background:none;border:none;margin:0 0 0 16px;cursor:pointer}.s12 svg path,.s12 svg rect{-webkit-transition:.2s;-o-transition:.2s;transition:.2s}.s12:hover svg path{fill-opacity:.4}.s12:hover svg rect{stroke-opacity:.4}.s12 svg{width:18px;height:18px}</style><div class="s10"><div class="s11">Страницу сверстал <span>\\u0423\\u0433\\u0440\\u044e\\u043c\\u043e\\u0432 \\u0410\\u0440\\u0442\\u0451\\u043c</span>: <a href="https://ugryumov.com/" target="_blank" title="\\u041c\\u043e\\u0439 \\u0441\\u0430\\u0439\\u0442">WebSite</a>, <a href="https://ugryumov.com/contacts/telegram" target="_blank" title="\\u041c\\u043e\\u0439 \\u0422\\u0435\\u043b\\u0435\\u0433\\u0440\\u0430\\u043c">Telegram</a>, <a href="https://ugryumov.com/contacts/vk" target="_blank" title="\\u042f \\u0432\\u043e \\u0412\\u043a\\u043e\\u043d\\u0442\\u0430\\u043a\\u0442\\u0435">\\u0412\\u043a\\u043e\\u043d\\u0442\\u0430\\u043a\\u0442\\u0435</a></div><button class="s12"><svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.75737 5.818L5.81803 4.75734L8.99999 7.9393L12.182 4.75732L13.2426 5.81798L10.0607 8.99996L13.2427 12.182L12.182 13.2426L8.99999 10.0606L5.81801 13.2426L4.75735 12.1819L7.93933 8.99996L4.75737 5.818Z" fill="#333333" fill-opacity="0.6"/><rect x="0.5" y="0.5" width="17" height="17" rx="8.5" stroke="#333333" stroke-opacity="0.6"/></svg></button></div>\'),\n          document.querySelector("body").append(e);\n      }\n      setTimeout(() => {\n        const t = document.querySelector(".s8"),\n          e = t.querySelector(".s12");\n        t.classList.toggle("s9"),\n          e.addEventListener("click", () => {\n            t.classList.remove("s9");\n          });\n      }, 1);\n    }\n  };\n}\ns();\n\n\n//# sourceURL=webpack://start-gulp/./src/js/index.js?')},"./src/js/utils/functions.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "bodyLock": () => (/* binding */ bodyLock),\n/* harmony export */   "bodyLockStatus": () => (/* binding */ bodyLockStatus),\n/* harmony export */   "bodyLockToggle": () => (/* binding */ bodyLockToggle),\n/* harmony export */   "bodyUnlock": () => (/* binding */ bodyUnlock),\n/* harmony export */   "getRandomInt": () => (/* binding */ getRandomInt),\n/* harmony export */   "getSiblings": () => (/* binding */ getSiblings),\n/* harmony export */   "isMobile": () => (/* binding */ isMobile),\n/* harmony export */   "isWebp": () => (/* binding */ isWebp),\n/* harmony export */   "nodeArray": () => (/* binding */ nodeArray),\n/* harmony export */   "removeAllClasses": () => (/* binding */ removeAllClasses)\n/* harmony export */ });\n// Удаляет у всех элементов items класс itemClass\nfunction removeAllClasses(items, itemClass) {\n  if (typeof items == "string") {\n    items = document.querySelectorAll(items);\n  }\n\n  for (let i = 0; i < items.length; i++) {\n    if (typeof itemClass === "object") {\n      items[i].classList.remove(...itemClass);\n    } else {\n      items[i].classList.remove(itemClass);\n    }\n  }\n}\n//========================================================================================================================================================\n\n// Создает Array из NodeList и возвращает его\nfunction nodeArray(selector, parent = document) {\n  return Array.from(parent.querySelectorAll(selector));\n}\n//========================================================================================================================================================\n\n// Получаем все соседние элементы\nfunction getSiblings(elem) {\n  const siblings = [];\n  let sibling = elem;\n\n  while (sibling.previousSibling) {\n    sibling = sibling.previousSibling;\n    sibling.nodeType == 1 && siblings.push(sibling);\n  }\n\n  sibling = elem;\n  while (sibling.nextSibling) {\n    sibling = sibling.nextSibling;\n    sibling.nodeType == 1 && siblings.push(sibling);\n  }\n\n  return siblings;\n}\n//========================================================================================================================================================\n\n// Возвращает рандомное целое число\nfunction getRandomInt(min, max) {\n  return (\n    Math.floor(Math.random() * (Math.floor(max) + 1 - Math.ceil(min))) +\n    Math.ceil(min)\n  );\n}\n//========================================================================================================================================================\n\n// Проверка поддержки webp, добавление класса webp или no-webp тегу body\nfunction isWebp() {\n  // Проверка поддержки webp\n  function testWebP(callback) {\n    let webP = new Image();\n\n    webP.onload = webP.onerror = function () {\n      callback(webP.height == 2);\n    };\n\n    webP.src =\n      "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";\n  }\n\n  testWebP(function (support) {\n    let className = support === true ? "webp" : "no-webp";\n    document.body.classList.add(className);\n  });\n}\n//========================================================================================================================================================\n\n// Вспомогательные модули блокировки прокрутки и резкого сдвига\nlet bodyLockStatus = true;\nfunction bodyLockToggle(delay = 100) {\n  if (document.documentElement.classList.contains("_lock")) {\n    bodyUnlock(delay);\n  } else {\n    bodyLock(delay);\n  }\n}\n// Разблокировать скролл\nfunction bodyUnlock(delay = 100) {\n  let body = document.querySelector("body");\n\n  if (bodyLockStatus) {\n    let lockPadding = document.querySelectorAll("[data-lp]");\n\n    setTimeout(() => {\n      for (let index = 0; index < lockPadding.length; index++) {\n        const el = lockPadding[index];\n\n        el.style.paddingRight = "0px";\n      }\n\n      body.style.paddingRight = "0px";\n      document.documentElement.classList.remove("_lock");\n    }, delay);\n\n    bodyLockStatus = false;\n\n    setTimeout(function () {\n      bodyLockStatus = true;\n    }, delay);\n  }\n}\n\n// Заблокировать скролл\nfunction bodyLock(delay = 100) {\n  let body = document.querySelector("body");\n\n  if (bodyLockStatus) {\n    let lock_padding = document.querySelectorAll("[data-lp]");\n\n    for (let index = 0; index < lock_padding.length; index++) {\n      const el = lock_padding[index];\n\n      el.style.paddingRight =\n        window.innerWidth -\n        document.querySelector(".wrapper").offsetWidth +\n        "px";\n    }\n\n    body.style.paddingRight =\n      window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";\n    document.documentElement.classList.add("_lock");\n\n    bodyLockStatus = false;\n\n    setTimeout(function () {\n      bodyLockStatus = true;\n    }, delay);\n  }\n}\n//========================================================================================================================================================\n\n// Является ли устройство сенсорным\nconst isMobile = {\n  Android: function () {\n    return navigator.userAgent.match(/Android/i);\n  },\n  BlackBerry: function () {\n    return navigator.userAgent.match(/BlackBerry/i);\n  },\n  iOS: function () {\n    return navigator.userAgent.match(/iPhone|iPad|iPod/i);\n  },\n  Opera: function () {\n    return navigator.userAgent.match(/Opera Mini/i);\n  },\n  Windows: function () {\n    return navigator.userAgent.match(/IEMobile/i);\n  },\n  any: function () {\n    return (\n      isMobile.Android() ||\n      isMobile.BlackBerry() ||\n      isMobile.iOS() ||\n      isMobile.Opera() ||\n      isMobile.Windows()\n    );\n  },\n};\n//========================================================================================================================================================\n\n\n//# sourceURL=webpack://start-gulp/./src/js/utils/functions.js?')},"./src/js/utils/modules.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Accordions": () => (/* binding */ Accordions),\n/* harmony export */   "Modals": () => (/* binding */ Modals),\n/* harmony export */   "arrowUp": () => (/* binding */ arrowUp),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   "fixElemOverFooter": () => (/* binding */ fixElemOverFooter),\n/* harmony export */   "labelTextfield": () => (/* binding */ labelTextfield),\n/* harmony export */   "onlyDigit": () => (/* binding */ onlyDigit),\n/* harmony export */   "select": () => (/* binding */ select),\n/* harmony export */   "tabs": () => (/* binding */ tabs)\n/* harmony export */ });\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ "./src/js/utils/functions.js");\n\n\n/**\n * Аккордеон\n *\n * INFO: Атрибуты\n * data-acc-container - контейнер с аккордеонами\n * data-acc-hidden-sibling - (указывать у контейнера) если указан, при открытии аккордеона, все сосоднии будут закрываться\n * data-acc="<id-acc || Null>" - этот атрибут должен иметь элемент, являющийся аккордеоном\n * data-acc-toggler - элемент внутри аккордеона, открывающий его\n * data-acc-body - тело аккордеона\n * data-acc-opener="<id-acc>" - внешняя кнопка, открывающая аккордеон.\n *\n *\n * TODO: Что еще можно сделать\n * this.prevAcc - предыдущий аккордеон\n * this.update() - Функционал обновления аккордеонов\n * События\n * Сделать возможность не указывать атрибут у контейнера. В этом случае, контейнером будет являться родитель аккордеонов\n * Подумать надо объединением opener и toggler. Они выполняют примерно один и тот же функционал\n * this.toggle(<id-acc>) - если аккордеон открыт, он закроется. Если закрыт, он закроется\n */\n// export class Accordions {\n//     attrs = {\n//         container: \'data-acc-container\',\n//         hiddenSibling: \'data-acc-hidden-sibling\',\n//         acc: \'data-acc\',\n//         toggler: \'data-acc-toggler\',\n//         body: \'data-acc-body\',\n//         opener: \'data-acc-opener\',\n//     }\n\n//     classNames = {\n//         open: \'is-open\'\n//     }\n\n//     _currentAcc = {}\n\n//     accArr = []\n//     hiddenSibling = false\n\n//     constructor(selector) {\n//         this.init(selector)\n//     }\n\n//     init(selector) {\n//         let _accArr = Array.from( null !== selector ? typeof(selector) === \'string\' ? document.querySelectorAll(selector) : selector : document.querySelectorAll(`[${this.attrs.container}]`))\n//         this.accArr = _accArr.map(e => Array.from(e.querySelectorAll(`[${this.attrs.acc}]`)))\n//         this._combAccArr = Array().concat(...this.accArr)\n//         this._combAccArr.forEach(_acc => this.close(_acc, false))\n//         this._clickToggler()\n//         this._outOpener()\n//     }\n\n//     open(selector) {\n//         const _acc = selector === undefined ? this._currentAcc.acc : typeof(selector) === \'string\' ? document.querySelector(selector) : selector\n\n//         if (_acc.classList.contains(this.classNames.open)) return\n\n//         this._setCurrentAcc(_acc)\n\n//         if (this.hiddenSibling || this._currentAcc.container.hasAttribute(`${this.attrs.hiddenSibling}`)) {\n//             const _accElems = Array.from(this._currentAcc.container.querySelectorAll(`[${this.attrs.acc}]`))\n\n//             _accElems.forEach(_acc => {\n//                 if (_acc.classList.contains(this.classNames.open)) {\n//                     this.close(_acc, false)\n//                 }\n//             })\n//         }\n\n//         this._currentAcc.acc.classList.add(this.classNames.open)\n//         this._currentAcc.body.style = `\n//             max-height: ${this._currentAcc.body.scrollHeight}px;\n//             opacity: 1;\n//             visibility: visible;\n//         `\n//     }\n\n//     close(selector, makeCurrent = false) {\n//         const _acc = selector === undefined ? this._currentAcc.acc : typeof(selector) === \'string\' ? document.querySelector(selector) : selector\n//         const _body = selector === undefined ? this._currentAcc.body : _acc.querySelector(`[${this.attrs.body}]`)\n//         if (makeCurrent) this._setCurrentAcc(_acc)\n\n//         _acc.classList.remove(this.classNames.open)\n//         _body.style = `\n//             max-height: 0;\n//             opacity: 0;\n//             visibility: hidden;\n//         `\n//     }\n\n//     _outOpener() {\n//         document.addEventListener(\'click\', e => {\n\n//             if (e.target.hasAttribute(this.attrs.opener) || e.target.closest(`[${this.attrs.opener}]`)) {\n//                 const _opener = e.target.hasAttribute(this.attrs.opener) ? e.target : e.target.closest(`[${this.attrs.opener}]`)\n//                 const _acc = document.querySelector(`[${this.attrs.acc}=${_opener.getAttribute(this.attrs.opener)}]`)\n\n//                 this.open(_acc)\n//             }\n//         })\n//     }\n\n//     _clickToggler() {\n//         this._combAccArr.forEach(_acc => {\n//             const _toggler = _acc.querySelector(`[${this.attrs.toggler}]`)\n\n//             _toggler.addEventListener(\'click\', e => {\n//                 this._setCurrentAcc(_acc)\n\n//                 if (!_acc.classList.contains(this.classNames.open)) {\n//                     this.open()\n//                 }\n//                 else {\n//                     this.close()\n//                 }\n//             })\n//         })\n//     }\n\n//     _setCurrentAcc(_acc) {\n//         this._currentAcc.container = _acc.closest(`[${this.attrs.container}]`)\n//         this._curren,tAcc.acc = _acc\n//         this._currentAcc.toggler = _acc.querySelector(`[${this.attrs.toggler}]`)\n//         this._currentAcc.body = _acc.querySelector(`[${this.attrs.body}]`)\n//     }\n// }\n\nclass Accordions {\n  attrs = {\n    container: "data-acc-container",\n    hiddenSibling: "data-acc-hidden-sibling",\n    acc: "data-acc",\n    toggler: "data-acc-toggler",\n    body: "data-acc-body",\n    opener: "data-acc-opener",\n  };\n\n  classNames = {\n    open: "is-open",\n  };\n\n  _currentAcc = {};\n\n  accArr = [];\n  hiddenSibling = false;\n\n  constructor(selector) {\n    this.init(selector);\n  }\n\n  init(selector) {\n    let _accArr = Array.from(\n      null != selector\n        ? typeof selector === "string"\n          ? document.querySelectorAll(selector)\n          : selector\n        : document.querySelectorAll(`[${this.attrs.container}]`)\n    );\n    this.accArr = _accArr.map((e) =>\n      Array.from(e.querySelectorAll(`[${this.attrs.acc}]`))\n    );\n    this._combAccArr = Array().concat(...this.accArr);\n    this._clickToggler();\n    this._outsideOpener();\n\n    this._combAccArr.forEach((_acc) => {\n      _acc.Accordions = this;\n\n      if (!_acc.classList.contains("is-open")) {\n        this.close(_acc, false);\n      } else {\n        this.open(_acc, false);\n      }\n    });\n  }\n\n  open(selector, notOpen = true, maxHeight = null) {\n    const _acc =\n      selector === undefined\n        ? this._currentAcc.acc\n        : typeof selector === "string"\n        ? document.querySelector(selector)\n        : selector;\n\n    if (_acc.classList.contains(this.classNames.open) && notOpen) return;\n\n    this._setCurrentAcc(_acc);\n\n    if (\n      this.hiddenSibling ||\n      this._currentAcc.container.hasAttribute(`${this.attrs.hiddenSibling}`)\n    ) {\n      const _accElems = Array.from(\n        this._currentAcc.container.querySelectorAll(`[${this.attrs.acc}]`)\n      );\n\n      _accElems.forEach((_acc) => {\n        if (_acc.classList.contains(this.classNames.open)) {\n          this.close(_acc, false);\n        }\n      });\n    }\n\n    this._currentAcc.acc.classList.add(this.classNames.open);\n    this._currentAcc.body.style = `\n            max-height: ${\n              maxHeight === null\n                ? this._currentAcc.body.scrollHeight\n                : maxHeight\n            }px;\n            opacity: 1;\n            visibility: visible;\n        `;\n\n    setTimeout(() => {\n      this._currentAcc.body.style.overflow = "initial";\n    }, 400);\n\n    const _eAccOpen = new Event("acc-open");\n    _eAccOpen.data = this;\n\n    _acc.dispatchEvent(_eAccOpen);\n  }\n\n  close(selector, makeCurrent = false) {\n    const _acc =\n      selector === undefined\n        ? this._currentAcc.acc\n        : typeof selector === "string"\n        ? document.querySelector(selector)\n        : selector;\n    const _body =\n      selector === undefined\n        ? this._currentAcc.body\n        : _acc.querySelector(`[${this.attrs.body}]`);\n    if (makeCurrent) this._setCurrentAcc(_acc);\n\n    _acc.classList.remove(this.classNames.open);\n    _body.style.maxHeight = 0;\n    _body.style.opacity = 0;\n    _body.style.visibility = "hidden";\n\n    const _eAccClose = new Event("acc-close");\n    _eAccClose.data = this;\n\n    _acc.dispatchEvent(_eAccClose);\n  }\n\n  _outsideOpener() {\n    document.addEventListener("click", (e) => {\n      if (\n        e.target.hasAttribute(this.attrs.opener) ||\n        e.target.closest(`[${this.attrs.opener}]`)\n      ) {\n        const _opener = e.target.hasAttribute(this.attrs.opener)\n          ? e.target\n          : e.target.closest(`[${this.attrs.opener}]`);\n        const _acc = document.querySelector(\n          `[${this.attrs.acc}=${_opener.getAttribute(this.attrs.opener)}]`\n        );\n\n        this.open(_acc);\n      }\n    });\n  }\n\n  _clickToggler() {\n    this._combAccArr.forEach((_acc) => {\n      const _toggler = _acc.querySelector(`[${this.attrs.toggler}]`);\n\n      _toggler.addEventListener("click", (e) => {\n        this._setCurrentAcc(_acc);\n\n        if (!_acc.classList.contains(this.classNames.open)) {\n          this.open();\n        } else {\n          this.close();\n        }\n      });\n    });\n  }\n\n  _setCurrentAcc(_acc) {\n    this._currentAcc.container = _acc.closest(`[${this.attrs.container}]`);\n    this._currentAcc.acc = _acc;\n    this._currentAcc.toggler = _acc.querySelector(`[${this.attrs.toggler}]`);\n    this._currentAcc.body = _acc.querySelector(`[${this.attrs.body}]`);\n  }\n}\n\n/**\n * Модальное окно\n *\n * INFO: Атрибуты (все атрибуты находятся в св-ве attrs)\n * data-modal-id="<id-modal>" - (modalId) каждая модалка имеет этот атрибут, в котором мы указываем ее id\n * data-close-on-bg - (modalCloseOnBg) модалка, которая должна закрываться при клике по ее фону, должна иметь этот атрибут\n * data-modal-open="<id-modal>" - (btnModalOpen) имеет элемент, при нажатии на который открывается модалка\n * data-modal-close="<id-modal || Null>" - (btnModalClose) имеет элемент, при нажатии на который, модальное окно закрывается. Если елемент находится внутри модалки, которую он должен закрыть, в значении атрибута указывать id модалки необязательно (можно оставить его пустым). Значение стоит указывать, если элемент, который должен закрыть модалку, находится вне контейнера с атрибутом data-modal-id\n *\n * INFO: Свойства\n * attrs - (Object) названия атрибутов\n * classNames - (Object) названия классов\n * modalList - (NodeList) список всех модальных окон (для обновления списка использовать updateModalList())\n * openingBtnList - (NodeList) список открывающих кнопок\n * modalIsShow - (Boolean) модальное окно показано\n * modalShow - (Element) показанное модальное окно\n * modalShowId - (String) id показанного модального окна\n * keyEsc - (Boolean) закрывать модалки при нажатии клавиши Esc. По умолчанию - true\n * useHash - (Boolean) использовать хеш. Если в url указан хеш равный id модалки, модалка откроется. По умолчанию - true\n * historyHash - (Boolean) сохранять хеш в истории браузера. Если useHash === false, то historyHash будет равен false. По умолчанию - false\n * hash - (String) значение хеша\n *\n * INFO: Функции\n * open(<String || Element>) - метод, открывающий модалку\n * close(<String || Element || Null>) - метод, закрывающий модалку. Если скобки оставить пустыми, закроется открытая модалка\n * update() - метод, обновляющий список модалок (this.modalList) и список кнопок (this.openingBtnList)\n * updateModalList() - метод, обновляющий список модалок (this.modalList)\n * updateOpeningBtnList() - метод, обновляющий список кнопок (this.openingBtnList)\n *\n *\n * TODO: Что еще можно сделать\n * (Атрибуты data-modal-hash и data-modal-hash-history. В случае если this.useHash === false)\n * data-modal-hash - указывается у модалки, которая должна открываться по хешу\n * data-modal-hash-history - указывается у модалки, которая должна быть сохранена в истории ( использовать вместе с первым атрибутом )\n * Прописать возомжные ошибки\n * Анимацию появления с помощью js\n * Если указан id модалки при загрузке страницы, то модалка должна открываться без плавной анимации\n * События\n * Если при this.useHash = true, до открытия модалки в url был указан хеш не принадлежащий ни к одной модалке, то при закрытии модалки в url должен указываться тот самый хеш\n * Возможность открытия нескольких модалок\n * Закрытие/открытие модалок по таймеру\n */\nclass Modals {\n  attrs = {\n    modalId: "data-modal-id",\n    modalCloseOnBg: "data-close-on-bg",\n    btnModalOpen: "data-modal-open",\n    btnModalClose: "data-modal-close",\n  };\n  classNames = {\n    modalShow: "is-show",\n    modalBg: "modal__bg",\n  };\n  modalList = document.querySelectorAll(`[${this.attrs.modalId}]`);\n  openingBtnList = document.querySelectorAll(`[${this.attrs.btnModalOpen}]`);\n  openBtn = null;\n  modalIsShow = false;\n  modalShow = null;\n  modalShowId = null;\n  keyEsc = true;\n  useHash = true;\n  historyHash = !this.useHash ? false : false;\n  hash = null;\n\n  constructor(options) {\n    this._init();\n  }\n\n  // Открыть модальное окно\n  open(modal) {\n    if (typeof modal === "string") {\n      modal = document.querySelector(`[${this.attrs.modalId}=${modal}]`);\n    }\n\n    this.modalIsShow = true;\n    this.modalShow = modal;\n    this.modalShowId = modal.dataset.modalId;\n\n    this._modalBgClose();\n    modal.classList.add(this.classNames.modalShow);\n    (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyLock)();\n\n    // Событие открытия модалки\n    const _eModalOpenStart = new Event("modal-open");\n    _eModalOpenStart.data = { ...this };\n\n    modal.dispatchEvent(_eModalOpenStart);\n  }\n\n  // Закрыть модальное окно\n  close(modal) {\n    if (typeof modal === "undefined") {\n      if (this.modalShow != null) {\n        modal = this.modalShow;\n      } else {\n        console.error("[Modals]: Все модальные окна закрыты");\n        return;\n      }\n    }\n    if (typeof modal === "string") {\n      modal = document.querySelector(`[${this.attrs.modalId}=${modal}]`);\n    }\n    if (this.modalShow.dataset.closeOnBg != undefined) {\n      this._modalBg.removeEventListener("click", this._bgEvent);\n    }\n\n    // Событие закрытия модалки\n    const _eModalOpenClose = new Event("modal-close");\n    _eModalOpenStart.data = { ...this };\n\n    modal.dispatchEvent(_eModalOpenClose);\n\n    this.modalIsShow = false;\n    this.modalShow = null;\n    this.modalShowId = null;\n\n    modal.classList.remove(this.classNames.modalShow);\n    (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyUnlock)();\n  }\n\n  // Получить модальное окно\n  get(modalName) {\n    if (typeof modalName === "string") {\n      return (\n        this.modalList.find(\n          (e) => e.getAttribute(`${this.attrs.modalId}`) === modalName\n        ) || null\n      );\n    } else if (typeof modalName === "object") {\n      return modalName.map(\n        (modalName) =>\n          this.modalList.find(\n            (e) => e.getAttribute(`${this.attrs.modalId}`) === modalName\n          ) || null\n      );\n    } else {\n      return this.modalList;\n    }\n  }\n\n  // Обновляет список модалок и кнопок\n  update() {\n    this.updateModalList();\n    this.updateOpeningBtnList();\n  }\n\n  // Обновить список модальных окон\n  updateModalList() {\n    this.modalList = document.querySelectorAll(`[${this.attrs.modalId}]`);\n  }\n\n  // Обновить список кнопок, открывающих модальные окна\n  updateOpeningBtnList() {\n    this.openingBtnList = document.querySelectorAll(\n      `[${this.attrs.btnModalOpen}]`\n    );\n  }\n\n  // Инизиализация Modal\n  _init() {\n    this._btnOpen();\n    this._btnClose();\n    if (this.keyEsc) this._keyEscClose();\n    if (this.useHash) this._watchHash();\n  }\n\n  // Открыть модалку при клике по кнопке c атрибутом this.attrs.btnModalOpen\n  _btnOpen() {\n    document.addEventListener("click", (e) => {\n      if (\n        e.target.dataset.modalOpen != undefined ||\n        e.target.closest(`[${this.attrs.btnModalOpen}]`)\n      ) {\n        const btnOpenModal =\n          e.target.dataset.modalOpen != undefined\n            ? e.target\n            : e.target.closest(`[${this.attrs.btnModalOpen}]`);\n\n        this.openBtn = btnOpenModal;\n\n        this.open(btnOpenModal.dataset.modalOpen);\n        if (this.useHash) this._setHash();\n      }\n    });\n  }\n\n  // Закрыть модалку при клике по кнопке с атрибутом this.attrs.btnModalClose\n  _btnClose() {\n    document.addEventListener("click", (e) => {\n      if (\n        e.target.dataset.modalClose != undefined ||\n        e.target.closest(`[${this.attrs.btnModalClose}]`)\n      ) {\n        if (this.useHash) this._clearHash();\n        this.close(\n          document.querySelector(`[${this.attrs.modalId}=${this.modalShowId}]`)\n        );\n      }\n    });\n  }\n\n  // Закрытие модалки при клике по фону. Работает только у модалок, у которых ест атрибут this.attrs.modalCloseOnBg\n  _modalBgClose() {\n    if (this.modalShow.dataset.closeOnBg === undefined) return;\n\n    this._modalBg = this.modalShow.querySelector(`.${this.classNames.modalBg}`);\n    this._bgEvent = () => {\n      if (this.useHash) this._clearHash();\n      this.close(this.modalShow);\n    };\n\n    this._modalBg.addEventListener("click", this._bgEvent, { once: true });\n  }\n\n  // Закрытие модалки при нажатии клавиши Esc\n  _keyEscClose() {\n    document.addEventListener("keydown", (e) => {\n      if (e.key === "Escape") {\n        if (this.useHash) this._clearHash();\n        this.close();\n      }\n    });\n  }\n\n  // Следим за хешем\n  _watchHash() {\n    this._checkHash();\n    if (this.historyHash) {\n      window.addEventListener("hashchange", (e) => {\n        this._checkHash();\n      });\n    }\n  }\n\n  // Проверка хеша\n  _checkHash() {\n    const hash = window.location.hash.replace("#", "");\n    this.hash = hash === "" ? null : hash;\n\n    if (hash != "" && document.querySelector(`[data-modal-id=${hash}]`)) {\n      this.open(hash);\n    }\n    if (hash === "" && this.historyHash && this.modalShow) {\n      this.close();\n    }\n  }\n\n  // Установка хеша, равного id модалки\n  _setHash() {\n    const href = location.origin + location.pathname + "#" + this.modalShowId;\n    history[this.historyHash ? "pushState" : "replaceState"]({}, "", href);\n  }\n\n  // Удаление хеша\n  _clearHash() {\n    const href = location.href.replace(/#[\\w-]+/, "");\n    history[this.historyHash ? "pushState" : "replaceState"]({}, "", href);\n  }\n}\n//========================================================================================================================================================\n\n// Табы\n// data-tab - указывается у контейнера с карточками и табами\n// data-tab-btn="<category>" - кнопки(табы), при клике по которым меняется контент. Если указать в значении all, то покажутся все карточки.\n// data-tab-card="<category>" - карточки с категорией, к которой они относятся\nfunction tabs() {\n  const tabElems = document.querySelectorAll("[data-tab]");\n\n  for (let i = 0; i < tabElems.length; i++) {\n    const tab = tabElems[i];\n    const btnElems = tab.querySelectorAll("[data-tab-btn]");\n    const allCards = tab.querySelectorAll("[data-tab-card]");\n\n    for (let i = 0; i < btnElems.length; i++) {\n      const btn = btnElems[i];\n\n      btn.addEventListener("click", (e) => {\n        const btnData = btn.dataset.tabBtn;\n        const cardElems = tab.querySelectorAll(`[data-tab-card=${btnData}]`);\n\n        (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeAllClasses)(btnElems, "is-active");\n        (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeAllClasses)(allCards, "is-show");\n\n        btn.classList.add("is-active");\n        // tabRoller()\n\n        if (btnData === "all") {\n          for (let i = 0; i < allCards.length; i++) {\n            const card = allCards[i];\n\n            card.classList.add("is-show");\n          }\n        } else {\n          for (let i = 0; i < cardElems.length; i++) {\n            const card = cardElems[i];\n\n            card.classList.add("is-show");\n          }\n        }\n      });\n    }\n  }\n\n  // window.addEventListener(\'resize\', e => {\n  //     tabRoller()\n  // })\n\n  // Ползунок у табов\n  // tabRoller()\n  function tabRoller(tab) {\n    const roller = tab.querySelector("[data-tab-roller]");\n    const tabActive = tab.querySelector("[data-tab-btn].is-active");\n\n    roller.style.width =\n      tabActive.clientWidth -\n      parseInt(window.getComputedStyle(tabActive).paddingRight) -\n      parseInt(window.getComputedStyle(tabActive).paddingLeft) +\n      "px"; // Определяем ширину ползунка\n    roller.style.left =\n      tabActive.offsetLeft +\n      parseInt(window.getComputedStyle(tabActive).paddingRight) +\n      "px"; // Определяем отступ слева у ползунка\n  }\n}\n//========================================================================================================================================================\n\n// Плейсхолдер текстовых полей\nfunction labelTextfield(container = document) {\n  const textfieldElems = container.querySelectorAll(".tf");\n\n  for (let i = 0; i < textfieldElems.length; i++) {\n    const textfield = textfieldElems[i];\n    const input = textfield.querySelector("input, textarea");\n\n    if (input.value != "") {\n      textfield.classList.add("has-change-label");\n    }\n\n    input.addEventListener("focus", (e) => {\n      textfield.classList.add("has-change-label");\n    });\n\n    input.addEventListener("blur", (e) => {\n      if (input.value === "") {\n        textfield.classList.remove("has-change-label");\n      }\n    });\n  }\n}\n//========================================================================================================================================================\n\n// Аккордеон для списков\nclass AccordionForList {\n  constructor(acc) {\n    this.acc = acc;\n    this.list = acc.querySelector(".acc-category__block-list");\n    this.itemArr = Array.from(this.list.querySelectorAll("li"));\n    this.btnMore = acc.querySelector(".acc-category__block-more");\n    this.contentExternal = acc.closest(".acc-category__content");\n\n    this._init();\n  }\n\n  _init() {\n    this.firstSixItemsHeight = this.itemArr\n      .slice(0, 6)\n      .reduce((accum, e) => accum + e.offsetHeight, 0);\n    this.listHeight = this.itemArr.reduce(\n      (accum, e) => accum + e.offsetHeight,\n      0\n    );\n    this.close();\n\n    this.btnMore.addEventListener("click", (e) => {\n      if (this.acc.classList.contains("is-open")) {\n        this.close();\n      } else {\n        this.open();\n      }\n    });\n  }\n\n  open() {\n    this.list.style.maxHeight = this.listHeight + "px";\n    this.acc.classList.add("is-open");\n    this.btnMore.innerText = "Скрыть";\n  }\n\n  close() {\n    this.list.style.maxHeight = this.firstSixItemsHeight + "px";\n    this.acc.classList.remove("is-open");\n    this.btnMore.innerText = "Показать еще";\n  }\n}\n\n//========================================================================================================================================================\n\n// Списки выбора\nfunction select() {\n  // Проверяем есть ли выбранные элементы при загрузке страницы. Если есть, то селект заполняется\n  const selectedItemElems = document.querySelectorAll(\n    ".select-dropdown__item.is-selected"\n  );\n\n  for (let i = 0; i < selectedItemElems.length; i++) {\n    const selectedItem = selectedItemElems[i];\n    const select = selectedItem.closest(".select");\n    const sTitle = select.querySelector(".select-input__title");\n    const sInput = select.querySelector("input[type=hidden]");\n\n    sTitle.innerText = selectedItem.innerHTML;\n    sInput.value = selectedItem.innerHTML;\n    select.classList.add("is-valid");\n  }\n\n  // Если пользователь кликнул по селекту, то он открывается/закрывается. Также он закроется если кликнуть вне его области\n  window.addEventListener("click", (e) => {\n    const target = e.target;\n\n    // Если пользователь кликнул вне зоны селекта\n    if (\n      !target.classList.contains("select") &&\n      !target.closest(".select.is-open")\n    ) {\n      if (document.querySelector(".select.is-open")) {\n        document.querySelector(".select.is-open").classList.remove("is-open");\n      }\n    }\n\n    // Если пользователь кликнул по шапке селекта\n    if (target.classList.contains("select-input")) {\n      target.parentElement.classList.toggle("is-open");\n    }\n\n    // Если пользователь выбрал пункт из списка селекта\n    if (target.classList.contains("select-dropdown__item")) {\n      const select = target.closest(".select");\n      const sTitle = select.querySelector(".select-input__title");\n      const sInput = select.querySelector("input[type=hidden]");\n      const neighbourTargets = target.parentElement.querySelectorAll(\n        ".select-dropdown__item"\n      );\n\n      sTitle.innerText = target.innerText;\n      sInput.value = target.innerText;\n\n      (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.removeAllClasses)(neighbourTargets, "is-selected");\n      target.classList.add("is-selected");\n\n      select.classList.remove("is-open");\n      select.classList.add("is-valid");\n    }\n  });\n}\n//========================================================================================================================================================\n\n// Кнопка "Наверх"\nfunction arrowUp() {\n  document.querySelector(".back-to-top").addEventListener("click", (e) => {\n    window.scrollBy(0, -window.scrollY);\n  });\n}\n//========================================================================================================================================================\n\n// Фиксация элемента с position: fixed над подвалом (чтобы не загораживал контент в подвале)\nfunction fixElemOverFooter(elem) {\n  const footer = document.querySelector("footer");\n\n  window.addEventListener("scroll", fixElem);\n\n  fixElem();\n  function fixElem() {\n    const footerPageY = footer.getBoundingClientRect().top;\n\n    if (footerPageY - window.innerHeight < 0) {\n      if (!elem.classList.contains("is-fixed")) {\n        elem.style.position = "absolute";\n        elem.style.bottom =\n          document.body.scrollHeight -\n          (footerPageY + window.scrollY) +\n          parseInt(\n            window.getComputedStyle(socialFixed).getPropertyValue("bottom")\n          ) +\n          "px";\n        elem.classList.add("is-fixed");\n      }\n    } else {\n      elem.removeAttribute("style");\n      elem.classList.remove("is-fixed");\n    }\n  }\n}\n\n// Только цифры и точка в инпутах\n// data-only-digit - input должен иметь этот атрибут\nfunction onlyDigit() {\n  const inputDigitElems = document.querySelectorAll("[data-only-digit]");\n\n  for (let i = 0; i < inputDigitElems.length; i++) {\n    const input = inputDigitElems[i];\n\n    input.addEventListener("keydown", (e) => {\n      if (e.key.search(/[\\d\\.]/)) {\n        e.preventDefault();\n      }\n    });\n\n    input.addEventListener("paste", (e) => {\n      if (e.clipboardData.getData("text/plain").search(/[\\d\\.]/)) {\n        e.preventDefault();\n      }\n    });\n  }\n}\n//========================================================================================================================================================\n\n// Открытие/закрытие моб. меню\nclass Menu {\n  constructor(selector) {\n    this.menu = document.querySelector(".menu");\n    this.menuIsOpen = false;\n\n    this._init();\n  }\n\n  _init() {\n    document.addEventListener("click", (e) => {\n      if (\n        e.target.classList.contains("[data-menu-close]") ||\n        e.target.closest("[data-menu-close]")\n      ) {\n        this.close();\n      }\n\n      if (e.target.classList.contains("menu") && this.menuIsOpen) {\n        this.close();\n      }\n\n      if (\n        e.target.classList.contains("[data-menu-open]") ||\n        e.target.closest("[data-menu-open]")\n      ) {\n        this.open();\n      }\n    });\n  }\n\n  open() {\n    this.menu.classList.add("is-show");\n    (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyLock)();\n\n    this.menuIsOpen = true;\n    this._addEvent("open");\n  }\n\n  close() {\n    this.menu.classList.remove("is-show");\n    (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.bodyUnlock)();\n\n    this.menuIsOpen = false;\n    this._addEvent("close");\n  }\n\n  _addEvent(eventName, options) {\n    const event = new Event(eventName);\n\n    event.Menu = this;\n\n    if (options && typeof options === "object")\n      event.Menu[options.key] = options.value;\n\n    this.menu.dispatchEvent(event);\n  }\n}\n\n//========================================================================================================================================================\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  Accordions,\n  Modals,\n  tabs,\n  labelTextfield,\n  select,\n  arrowUp,\n  fixElemOverFooter,\n  onlyDigit,\n  Menu,\n});\n\n\n//# sourceURL=webpack://start-gulp/./src/js/utils/modules.js?')}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];return void 0!==e||(e=__webpack_module_cache__[n]={exports:{}},__webpack_modules__[n](e,e.exports,__webpack_require__)),e.exports}__webpack_require__.d=(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/js/index.js")})();